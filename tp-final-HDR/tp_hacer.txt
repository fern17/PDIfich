Imagenes de alto rango dinamico:

Pasos:
Tomar 4 imagenes I_i de MxN con diferente exposición e_i, i=0,1,2,3, donde la exposición e_{i} < e_{i+1}.
Por ejemplo:
* e_0 = -2
* e_1 = -1
* e_2 = 1
* e_3 = 2

Notar que k_1 * I_0(i,j) = k_1 * I_1(i,j) = k_2 * I_2(i,j) = k_3 * I_3(i,j)
O sea, representan el mismo punto con distinta iluminación (exposición)

Realizar una imagen compuesta C 2Mx2N donde se juntan las 4 imágenes. De manera que:
C(0,0) = I_0(0,0)
C(0,1) = I_1(0,0)
C(1,1) = I_2(0,0)
C(1,0) = I_3(0,0)

C(0,2) = I_0(0,1)
C(0,3) = I_1(0,1)
....

El algoritmo para generar la imagen C compuesta es (creo):
La imagen compuesta es de 4Mx4N
Cada imagen de distinta exposición I_k es de MxN.

for i=0:4M
  for j=0:4N
    en la posicion C(i,j) se asigna el valor I_k(i/4,j/4) (division entera)
    donde k se calcula como:
    if i % 2 == 0 and j % 2 == 0: 
	k = 0
    if i % 2 == 1 and j % 2 == 0: 
	k = 1
    if i % 2 == 1 and j % 2 == 1: 
	k = 2
    if i % 2 == 0 and j % 2 == 1: 
	k = 3

Discretizar el kernel 1D W(x) en tantos elementos como sea necesario (por ejemplo, 49): http://en.wikipedia.org/wiki/Bicubic_interpolation#Bicubic_convolution_algorithm
Con a = -0.5, quedaría:

xx = abs(x)
if (xx < 1)
    W(x) = 1.5*xx^3 - 2.5*xx^2 + 1;
elseif (xx < 2)
    W(x) = -0.5*xx^3 + 2.5*xx^2 - 4*xx + 2;
else
    W(x) = 0;
end

W queda como un array de 49 valores x_i en 1D.

Para cada recuadro de 4x4 de toda la imagen C:
  Convolucionar con el kernel en cada fila. En cada fila hay 4 valores, convolucionarlo con el kernel de 49 valores. Obteniendo un sólo valor por fila
  A los 4 valores obtenidos en cada una de las 4 convoluciones, meterlos en un vector y convolucionarlos de nuevo con el mismo kernel.
  El valor resultado, se asigna a la imagen resultante.

